# **ZRC6 to ERC712 NFT Swap** Contracts

## Contracts

## burnScillaAndMintEVMNFTSwap.sol

### **Core Functionality**

* **Atomic Swap:** The primary function of the contract is to execute a burn-and-mint operation. A user initiates a transaction that first triggers a burn of one or more ZRC-6 NFTs on a designated Scilla contract and then mints/transfers the corresponding, pre-mapped ERC-721 NFTs to their EVM wallet.  
* **Single Collection Pair:** The contract is designed to work with a single, specific pair of NFT collections: one Scilla-based ZRC-6 collection and one EVM-based ERC-721 collection.  
* **Cross-Wallet Ownership Verification:** The contract must verify that the user initiating the EVM transaction is also the owner of the Scilla-based assets. This is achieved through a signature verification mechanism.

### Contract State and Configuration**

#### **Contract Addresses**

* The contract must store the addresses of the two NFT collections it services:  
  * scillaNFTCollectionAddress (ZRC-6)  
  * evmNFTCollectionAddress (ERC-721)  
* These addresses shall be immutable and set only once during contract deployment via the constructor.

#### **NFT ID Mapping**

* The contract must maintain a mapping to link specific Scilla ZRC-6 token IDs to their corresponding EVM ERC-721 token IDs.  
* **Data Structure:** mapping(uint256 \=\> uint256) private nftSwapMapping; (Scilla Token ID \-\> ERC-721 Token ID).  
* A swap operation for a given Scilla NFT is only possible if its ID exists as a key in this mapping.

### **Functions**

#### **swapZRC6NFTForErc721NFTByByrningZRC6 (User-Facing)**

This is the primary function for users to execute the NFT swap.

* **User Story:** As an NFT owner, I want to burn my ZRC-6 NFT and receive the equivalent ERC-721 NFT in my EVM wallet, proving I own both the source (ZilPay) and destination (EVM) wallets.  
* **Parameters:**  
  1. scilla\_address (string): The user's public Zilliqa address in hex format (i.e.., "0x...") that owns the NFTs.  
  2. scilla\_nft\_ids\_to\_swap (uint256\[\]): An array of ZRC-6 NFT token IDs to be burned and swapped.  
  3. signature (bytes): The cryptographic signature generated by signing the **caller's EVM address (msg.sender)** with the private key corresponding to the scilla\_address.  
* **Execution Logic:**  
  1. **Authentication & Verification:**  
     * The contract must prepare the message that was supposed to be signed. This message is the caller's EVM address (msg.sender).  
     * The contract must use the message and the provided signature to cryptographically recover the signer's public key, and from it, the signer's Zilliqa address.  
     * It must then verify that the recovered Zilliqa address matches the scilla\_address parameter. If they do not match, the transaction must revert, as this proves the caller does not have the private key for the claimed Scilla address.  
     * After authenticating the signature, the contract must use the Zilliqa interop layer to confirm that the scilla\_address is the actual owner of all NFTs in the scilla\_nft\_ids\_to\_swap array. If the ownership check fails for any NFT, the transaction must revert.  
  2. **Mapping Check:** For each ID in scilla\_nft\_ids\_to\_swap, the contract must verify that a corresponding mapping to an ERC-721 ID exists in nftSwapMapping. If any ID is not found, the transaction must revert.  
  3. **Burn Operation:** The contract will use the Zilliqa interoperability layer to call the burn (or equivalent) function on the scillaNFTCollectionAddress for each token ID in scilla\_nft\_ids\_to\_swap.  
  4. **Transfer Operation:** Upon successful completion of the burn, the contract will transfer the corresponding ERC-721 NFTs (retrieved from nftSwapMapping) to the msg.sender (the caller's EVM wallet address).  
* **Effects of a Successful Call:**  
  1. The ownership of all specified ZRC-6 NFTs on the Scilla collection is transferred to the zero address (or otherwise designated as burned).  
  2. The ownership of all corresponding ERC-721 NFTs on the EVM collection is transferred to the msg.sender.

#### **updateNFTSwapMapping (Admin-Facing)**

This is a privileged function for the contract owner to manage the NFT swap mappings.

* **Access Control:** This function must be restricted so that only the contract owner or an authorized administrator can call it.  
* **Purpose:** To add, update, or remove entries in the nftSwapMapping.  
* **Parameters:**  
  * scillaTokenIds (uint256\[\]): An array of ZRC-6 token IDs.  
  * erc721TokenIds (uint256\[\]): An array of corresponding ERC-721 token IDs.  
* **Logic:** The function will iterate through the provided arrays and update the nftSwapMapping accordingly. It should ensure that the input arrays have the same length.

### **5\. Assumptions and Dependencies**

* **Zilliqa Interoperability:** The contract relies on a functioning and accessible Zilliqa interoperability layer to make calls to the Scilla smart contract.  
* **Distinct Wallets:** It is assumed that the user holds their Scilla NFTs in a ZilPay wallet and interacts with this EVM contract using a separate EVM-compatible wallet (e.g., MetaMask).  
* **Scilla Contract Interface:** The target Scilla NFT contract must have a publicly callable burn function (or an equivalent function like Transfer to the zero address) that this EVM contract can invoke via the interop layer.

## Playgrond contracts

Playground contracts directory contains pre deployed testnet contracts that can be used to run the web application and test it out.

### notScarceZRC6.scilla

TODO add some description for `notScarceZRC6.scilla`that can be minted by anyone.

### erc721.sol

TODO add some description for `erc721.sol` that can mint tokens on the fly by addresses set as allowed minters. One of the addresses is the `burnScillaAndMintEVMNFTSwap.sol` contract  

## Foundry usage

**Foundry is a blazing fast, portable and modular toolkit for Ethereum application development written in Rust.**

Foundry consists of:

-   **Forge**: Ethereum testing framework (like Truffle, Hardhat and DappTools).
-   **Cast**: Swiss army knife for interacting with EVM smart contracts, sending transactions and getting chain data.
-   **Anvil**: Local Ethereum node, akin to Ganache, Hardhat Network.
-   **Chisel**: Fast, utilitarian, and verbose solidity REPL.

### Documentation

https://book.getfoundry.sh/

### Build

```shell
$ forge build
```

### Test

```shell
$ forge test
```

### Format

```shell
$ forge fmt
```

### Gas Snapshots

```shell
$ forge snapshot
```

### Anvil

```shell
$ anvil
```

### Deploy

```shell
$ forge script script/Counter.s.sol:CounterScript --rpc-url <your_rpc_url> --private-key <your_private_key>
```

### Cast

```shell
$ cast <subcommand>
```

### Help

```shell
$ forge --help
$ anvil --help
$ cast --help
```
