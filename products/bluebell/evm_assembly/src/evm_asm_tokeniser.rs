use evm::Opcode;

enum Token {
    Opcode(Opcode),
    Number(u64),
    HexNumber(Vec<u8>),
    Identifier(String),
}

pub fn tokenise(input: &str) -> Vec<Token> {
    let mut tokens = Vec::new();

    for word in input.split_whitespace() {
        let token = match word {
            "stop" => Token::Opcode(Opcode::STOP),
            "add" => Token::Opcode(Opcode::ADD),
            "mul" => Token::Opcode(Opcode::MUL),
            "sub" => Token::Opcode(Opcode::SUB),
            "div" => Token::Opcode(Opcode::DIV),
            "sdiv" => Token::Opcode(Opcode::SDIV),
            "mod" => Token::Opcode(Opcode::MOD),
            "smod" => Token::Opcode(Opcode::SMOD),
            "addmod" => Token::Opcode(Opcode::ADDMOD),
            "mulmod" => Token::Opcode(Opcode::MULMOD),
            "exp" => Token::Opcode(Opcode::EXP),
            "signextend" => Token::Opcode(Opcode::SIGNEXTEND),
            "lt" => Token::Opcode(Opcode::LT),
            "gt" => Token::Opcode(Opcode::GT),
            "slt" => Token::Opcode(Opcode::SLT),
            "sgt" => Token::Opcode(Opcode::SGT),
            "eq" => Token::Opcode(Opcode::EQ),
            "iszero" => Token::Opcode(Opcode::ISZERO),
            "and" => Token::Opcode(Opcode::AND),
            "or" => Token::Opcode(Opcode::OR),
            "xor" => Token::Opcode(Opcode::XOR),
            "not" => Token::Opcode(Opcode::NOT),
            "byte" => Token::Opcode(Opcode::BYTE),
            "calldataload" => Token::Opcode(Opcode::CALLDATALOAD),
            "calldatasize" => Token::Opcode(Opcode::CALLDATASIZE),
            "calldatacopy" => Token::Opcode(Opcode::CALLDATACOPY),
            "codesize" => Token::Opcode(Opcode::CODESIZE),
            "codecopy" => Token::Opcode(Opcode::CODECOPY),
            "shl" => Token::Opcode(Opcode::SHL),
            "shr" => Token::Opcode(Opcode::SHR),
            "sar" => Token::Opcode(Opcode::SAR),
            "pop" => Token::Opcode(Opcode::POP),
            "mload" => Token::Opcode(Opcode::MLOAD),
            "mstore" => Token::Opcode(Opcode::MSTORE),
            "mstore8" => Token::Opcode(Opcode::MSTORE8),
            "jump" => Token::Opcode(Opcode::JUMP),
            "jumpi" => Token::Opcode(Opcode::JUMPI),
            "pc" => Token::Opcode(Opcode::PC),
            "msize" => Token::Opcode(Opcode::MSIZE),
            "jumpdest" => Token::Opcode(Opcode::JUMPDEST),
            "push0" => Token::Opcode(Opcode::PUSH0),
            "push1" => Token::Opcode(Opcode::PUSH1),
            "push2" => Token::Opcode(Opcode::PUSH2),
            "push3" => Token::Opcode(Opcode::PUSH3),
            "push4" => Token::Opcode(Opcode::PUSH4),
            "push5" => Token::Opcode(Opcode::PUSH5),
            "push6" => Token::Opcode(Opcode::PUSH6),
            "push7" => Token::Opcode(Opcode::PUSH7),
            "push8" => Token::Opcode(Opcode::PUSH8),
            "push9" => Token::Opcode(Opcode::PUSH9),
            "push10" => Token::Opcode(Opcode::PUSH10),
            "push11" => Token::Opcode(Opcode::PUSH11),
            "push12" => Token::Opcode(Opcode::PUSH12),
            "push13" => Token::Opcode(Opcode::PUSH13),
            "push14" => Token::Opcode(Opcode::PUSH14),
            "push15" => Token::Opcode(Opcode::PUSH15),
            "push16" => Token::Opcode(Opcode::PUSH16),
            "push17" => Token::Opcode(Opcode::PUSH17),
            "push18" => Token::Opcode(Opcode::PUSH18),
            "push19" => Token::Opcode(Opcode::PUSH19),
            "push20" => Token::Opcode(Opcode::PUSH20),
            "push21" => Token::Opcode(Opcode::PUSH21),
            "push22" => Token::Opcode(Opcode::PUSH22),
            "push23" => Token::Opcode(Opcode::PUSH23),
            "push24" => Token::Opcode(Opcode::PUSH24),
            "push25" => Token::Opcode(Opcode::PUSH25),
            "push26" => Token::Opcode(Opcode::PUSH26),
            "push27" => Token::Opcode(Opcode::PUSH27),
            "push28" => Token::Opcode(Opcode::PUSH28),
            "push29" => Token::Opcode(Opcode::PUSH29),
            "push30" => Token::Opcode(Opcode::PUSH30),
            "push31" => Token::Opcode(Opcode::PUSH31),
            "push32" => Token::Opcode(Opcode::PUSH32),
            "dup1" => Token::Opcode(Opcode::DUP1),
            "dup2" => Token::Opcode(Opcode::DUP2),
            "dup3" => Token::Opcode(Opcode::DUP3),
            "dup4" => Token::Opcode(Opcode::DUP4),
            "dup5" => Token::Opcode(Opcode::DUP5),
            "dup6" => Token::Opcode(Opcode::DUP6),
            "dup7" => Token::Opcode(Opcode::DUP7),
            "dup8" => Token::Opcode(Opcode::DUP8),
            "dup9" => Token::Opcode(Opcode::DUP9),
            "dup10" => Token::Opcode(Opcode::DUP10),
            "dup11" => Token::Opcode(Opcode::DUP11),
            "dup12" => Token::Opcode(Opcode::DUP12),
            "dup13" => Token::Opcode(Opcode::DUP13),
            "dup14" => Token::Opcode(Opcode::DUP14),
            "dup15" => Token::Opcode(Opcode::DUP15),
            "dup16" => Token::Opcode(Opcode::DUP16),
            "swap1" => Token::Opcode(Opcode::SWAP1),
            "swap2" => Token::Opcode(Opcode::SWAP2),
            "swap3" => Token::Opcode(Opcode::SWAP3),
            "swap4" => Token::Opcode(Opcode::SWAP4),
            "swap5" => Token::Opcode(Opcode::SWAP5),
            "swap6" => Token::Opcode(Opcode::SWAP6),
            "swap7" => Token::Opcode(Opcode::SWAP7),
            "swap8" => Token::Opcode(Opcode::SWAP8),
            "swap9" => Token::Opcode(Opcode::SWAP9),
            "swap10" => Token::Opcode(Opcode::SWAP10),
            "swap11" => Token::Opcode(Opcode::SWAP11),
            "swap12" => Token::Opcode(Opcode::SWAP12),
            "swap13" => Token::Opcode(Opcode::SWAP13),
            "swap14" => Token::Opcode(Opcode::SWAP14),
            "swap15" => Token::Opcode(Opcode::SWAP15),
            "swap16" => Token::Opcode(Opcode::SWAP16),
            "#return" => Token::Opcode(Opcode::RETURN),
            "revert" => Token::Opcode(Opcode::REVERT),
            "invalid" => Token::Opcode(Opcode::INVALID),
            "eofmagic" => Token::Opcode(Opcode::EOFMAGIC),

            "sha3" => Token::Opcode(Opcode::SHA3),
            "address" => Token::Opcode(Opcode::ADDRESS),
            "balance" => Token::Opcode(Opcode::BALANCE),
            "selfbalance" => Token::Opcode(Opcode::SELFBALANCE),
            "basefee" => Token::Opcode(Opcode::BASEFEE),
            "origin" => Token::Opcode(Opcode::ORIGIN),
            "caller" => Token::Opcode(Opcode::CALLER),
            "callvalue" => Token::Opcode(Opcode::CALLVALUE),
            "gasprice" => Token::Opcode(Opcode::GASPRICE),
            "extcodesize" => Token::Opcode(Opcode::EXTCODESIZE),
            "extcodecopy" => Token::Opcode(Opcode::EXTCODECOPY),
            "extcodehash" => Token::Opcode(Opcode::EXTCODEHASH),
            "returndatasize" => Token::Opcode(Opcode::RETURNDATASIZE),
            "returndatacopy" => Token::Opcode(Opcode::RETURNDATACOPY),
            "blockhash" => Token::Opcode(Opcode::BLOCKHASH),
            "coinbase" => Token::Opcode(Opcode::COINBASE),
            "timestamp" => Token::Opcode(Opcode::TIMESTAMP),
            "number" => Token::Opcode(Opcode::NUMBER),
            "difficulty" => Token::Opcode(Opcode::DIFFICULTY),
            "gaslimit" => Token::Opcode(Opcode::GASLIMIT),
            "sload" => Token::Opcode(Opcode::SLOAD),
            "sstore" => Token::Opcode(Opcode::SSTORE),
            "gas" => Token::Opcode(Opcode::GAS),
            "log0" => Token::Opcode(Opcode::LOG0),
            "log1" => Token::Opcode(Opcode::LOG1),
            "log2" => Token::Opcode(Opcode::LOG2),
            "log3" => Token::Opcode(Opcode::LOG3),
            "log4" => Token::Opcode(Opcode::LOG4),
            "create" => Token::Opcode(Opcode::CREATE),
            "create2" => Token::Opcode(Opcode::CREATE2),
            "call" => Token::Opcode(Opcode::CALL),
            "callcode" => Token::Opcode(Opcode::CALLCODE),
            "delegatecall" => Token::Opcode(Opcode::DELEGATECALL),
            "staticcall" => Token::Opcode(Opcode::STATICCALL),
            "suicide" => Token::Opcode(Opcode::SUICIDE),
            "chainid" => Token::Opcode(Opcode::CHAINID),

            _ => {
                if let Ok(number) = word.parse::<u64>() {
                    Token::Number(number)
                } else if word.starts_with("0x") {
                    Token::HexNumber(hex::decode(&word[2..]).unwrap())
                } else {
                    Token::Identifier(word.to_string())
                }
            }
        };
        tokens.push(token);
    }

    tokens
}
