scilla_version 0

import ListUtils IntUtils PairUtils


library Staking

(* token address, rewarding amount, user stake, total stake *)
type RewardsCalculation =
| RewardsCalculation of ByStr20 Uint128 Uint128 Uint128

let true = True
let false = False
let uint32_zero = Uint32 0
let uint32_one = Uint32 1
let u256_zero = Uint256 0
let u128_zero = Uint128 0

let one_msg =
  fun (m : Message) =>
    let e = Nil {Message} in
    Cons {Message} m e

let u256_to_u32 =
  fun (n: Uint256) =>
    let m_opt = builtin to_uint32 n in
      match m_opt with
      | Some m => m
      | None => uint32_zero
      end

let bnum_to_uint256 =
  fun (b : BNum) =>
  let zero = BNum 0 in
  builtin bsub b zero

let i256_to_u256 =
  fun (n: Int256) =>
    let m_opt = builtin to_uint256 n in
      match m_opt with
      | Some m => m
      | None => u256_zero
      end

let iota : Uint32 -> Uint32 -> List Uint32 =
  fun (m : Uint32) => fun (n : Uint32) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {Uint32} in
        let acc_init = Pair {(List Uint32) Uint32} nil n in
        let one = Uint32 1 in
        let step = fun (xs_n : Pair (List Uint32) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one in
              let new_xs = Cons {Uint32} new_n xs in
              Pair {(List Uint32) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List Uint32) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {Uint32}
    end

let get_last_withdraw_cycle =
  fun (cycle_opt: Option Uint32) =>
    match cycle_opt with
    | Some cycle => cycle
    | None => uint32_one
    end

let get_uint128_opt =
  fun (value_opt: Option Uint128) =>
    match value_opt with
    | Some value => value
    | None => u128_zero
    end

let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end

(* Compute "(x * y) / z" with protection against integer overflows *)
let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end

(* epoch_per_cycle: *)
contract Staking(
    init_contract_owner: ByStr20,
    init_staking_token_address: ByStr20,
    init_block_num: Uint256,
    init_cycle: Uint32,
    epoch_per_cycle: Uint256 (*To set to roughly a day, use 2500*)
)

field contract_owner: ByStr20 = init_contract_owner
field last_block_num: Uint256 = init_block_num
field last_cycle: Uint32 = init_cycle
field total_stake: Uint128 = u128_zero
field total_stake_per_cycle: Map Uint32 Uint128 = Emp Uint32 Uint128
field stakers_bal: Map ByStr20 (Map Uint32 Uint128) = Emp ByStr20 (Map Uint32 Uint128)
field stakers_stake_per_cycle: Map ByStr20 (Map Uint32 Uint128) = Emp ByStr20 (Map Uint32 Uint128)
field last_withdraw_cycle: Map ByStr20 Uint32 = Emp ByStr20 Uint32
field rewards_per_cycle: Map ByStr20 Uint128 = Emp ByStr20 Uint128

procedure duplicate_total_stake_map(cycle_to_increase: Uint32)
  last_cycle_local <- last_cycle;
  total_stake_local <- total_stake;
  current_cycle = builtin add last_cycle_local cycle_to_increase;
  total_stake_per_cycle[current_cycle] := total_stake_local
end

procedure update_stake_map_onchange(is_deposit: Bool, change_amount: Uint128)
  current_bum <- & BLOCKNUMBER;
  current_block_num = bnum_to_uint256 current_bum;
  last_block_num <- last_block_num;
  current_block_num_256 = i256_to_u256 current_block_num;
  block_num_diff = builtin sub current_block_num_256 last_block_num;
  (* if there are 5 cycles need to be updated, then we need update 4 cycles use procedure duplicate_total_stake_map *)
  (* only update the last one upon the change of the stake *)
  cycle_to_increase = builtin div block_num_diff epoch_per_cycle;
  cycle_to_increase_32 = u256_to_u32 cycle_to_increase;
  (* this will create [1,2,3,4] if cycle_to_increase_u32 is 5 *)
  duplicated_list = iota uint32_one cycle_to_increase_32;
  forall duplicated_list duplicate_total_stake_map;
  (* handle the last cycle *)
  current_total_stake <- total_stake;
  last_cycle_local <- last_cycle;
  the_last_cycle = builtin add last_cycle_local cycle_to_increase_32;
  match is_deposit with
  | True =>
    new_total_stake = builtin add current_total_stake change_amount;
    total_stake := new_total_stake;
    total_stake_per_cycle[the_last_cycle] := new_total_stake;
    last_cycle := the_last_cycle
  | False =>
    new_total_stake = builtin sub current_total_stake change_amount;
    total_stake := new_total_stake;
    total_stake_per_cycle[the_last_cycle] := new_total_stake;
    last_cycle := the_last_cycle
  end
end

procedure update_staker_bal(user: ByStr20, amount: Uint128)
  last_cycle_local <- last_cycle;
  staker_bal_opt <- stakers_bal[user][last_cycle_local];
  new_amount = match staker_bal_opt with
                   | Some staker_bal =>
                     builtin add staker_bal amount
                   | None =>
                     amount
                   end;
  stakers_bal[user][last_cycle_local] := new_amount
end


procedure TransferZRC2ToContract(assetHash: ByStr20, amount: Uint128)
  msg_to_zrc2 = {_tag: "TransferFrom"; _recipient: assetHash; _amount: u128_zero;
                  from: _sender; to: _this_address; amount: amount};
  msgs = one_msg msg_to_zrc2;
  send msgs;
  e = { _eventname: "TransferToContract"; assetHash: assetHash; amount: amount };
  event e
end

procedure TransferZRC2FromContract(toAssetHash: ByStr20, address: ByStr20, amount: Uint128)
  msg_to_zrc2 = {_tag: "Transfer"; _recipient: toAssetHash; _amount: u128_zero;
                 to: address; amount: amount};
  msgs = one_msg msg_to_zrc2;
  send msgs
end

transition deposit(amount: Uint128)
  TransferZRC2ToContract init_staking_token_address amount;
  update_stake_map_onchange true amount;
  update_staker_bal _sender amount
end

procedure setup_rewards_distribution(p: RewardsCalculation)
  match p with
  | RewardsCalculation token_address rewarding_amount user_stake total_stake =>
    reward = muldiv rewarding_amount user_stake total_stake;
    (* todo what if the rewards too small, considering use another map *)
    TransferZRC2FromContract token_address _sender reward
  end
end

procedure calculate_rewards(cycle: Uint32)
  last_reward_cycle = builtin sub cycle uint32_one;
  last_staker_bal_opt <- stakers_stake_per_cycle[_sender][last_reward_cycle];
  last_staker_bal = get_uint128_opt last_staker_bal_opt;
  delete stakers_stake_per_cycle[_sender][last_reward_cycle];

  staker_bal_opt <- stakers_bal[_sender][last_reward_cycle];
  user_stake_this_cycle = match staker_bal_opt with
                              | Some staker_bal =>
                                builtin add staker_bal last_staker_bal
                              | None =>
                                last_staker_bal
                              end;

  stakers_bal[_sender][cycle] := user_stake_this_cycle;
  total_stake_per_opt <- total_stake_per_cycle[cycle];
  match total_stake_per_opt with
  | Some total_stake =>
    e = { _eventname: "calculate_rewards"; total_stake: total_stake; user_stake_this_cycle: user_stake_this_cycle };
    event e;
    is_total_stake_zero = builtin eq u128_zero total_stake;
    match is_total_stake_zero with
    | True =>
    | False =>
      rewards_per_cycle_local <- rewards_per_cycle;
      (* List (Pair ByStr20 Uint128)*)
      rewards_per_cycle_list = builtin to_list rewards_per_cycle_local;
      mapper = @list_map (Pair ByStr20 Uint128) RewardsCalculation;
      f = fun (p: Pair ByStr20 Uint128) =>
        match p with
        | Pair token_address amount =>
          RewardsCalculation token_address amount user_stake_this_cycle total_stake
        end;
      distribution_list = mapper f rewards_per_cycle_list;
      forall distribution_list setup_rewards_distribution
    end
  | None =>
  end
end

transition claim()
  update_stake_map_onchange true u128_zero;

  last_withdraw_cycle_opt <- last_withdraw_cycle[_sender];
  last_withdraw_cycle = get_last_withdraw_cycle last_withdraw_cycle_opt;
  last_cycle_local <- last_cycle;

  from_cycle = builtin add last_withdraw_cycle uint32_one;
  to_cycle = builtin add last_cycle_local uint32_one;
  reward_list = iota from_cycle to_cycle;
  e = { _eventname: "claim"; reward_list: reward_list};
  event e;
  forall reward_list calculate_rewards;
  last_withdraw_cycle[_sender] := last_cycle_local

end

transition RecipientAcceptTransferFrom(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  e = { _eventname: "RecipientAcceptTransferFrom"; initiator: initiator; sender: sender; recipient: recipient; amount: amount };
  event e
end

transition TransferFromSuccessCallBack(initiator: ByStr20, sender: ByStr20, recipient: ByStr20, amount: Uint128)
  e = { _eventname: "TransferFromSuccessCallBack"; initiator: initiator; sender: sender; recipient: recipient; amount: amount };
  event e
end
