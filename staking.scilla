scilla_version 0

library Staking

let true = True
let false = False

let uint32_zero = Uint32 0
let uint32_one = Uint32 1
let u256_zero = Uint256 0
let u128_zero = Uint128 0

let u256_to_u32 =
  fun (n: Uint256) =>
    let m_opt = builtin to_uint32 n in
      match m_opt with
      | Some m => m
      | None => uint32_zero
      end

let bnum_to_uint256 =
  fun (b : BNum) =>
  let zero = BNum 0 in
  builtin bsub b zero

let i256_to_u256 =
  fun (n: Int256) =>
    let m_opt = builtin to_uint256 n in
      match m_opt with
      | Some m => m
      | None => u256_zero
      end

let iota : Uint32 -> Uint32 -> List Uint32 =
  fun (m : Uint32) => fun (n : Uint32) =>
    let m_lt_n = builtin lt m n in
    match m_lt_n with
    | True =>
        let delta = builtin sub n m in
        let delta_nat = builtin to_nat delta in
        let nil = Nil {Uint32} in
        let acc_init = Pair {(List Uint32) Uint32} nil n in
        let one = Uint32 1 in
        let step = fun (xs_n : Pair (List Uint32) Uint32) => fun (ignore : Nat) =>
          match xs_n with
          | Pair xs n =>
              let new_n = builtin sub n one in
              let new_xs = Cons {Uint32} new_n xs in
              Pair {(List Uint32) Uint32} new_xs new_n
          end in
        let fold = @nat_fold (Pair (List Uint32) Uint32) in
        let xs_m = fold step acc_init delta_nat in
        match xs_m with
        | Pair xs m => xs
        end
    | False => Nil {Uint32}
    end

let get_last_withdraw_cycle =
  fun (cycle_opt: Option Uint32) =>
    match cycle_opt with
    | Some cycle => cycle
    | None => uint32_one
    end

let get_uint128_opt =
  fun (value_opt: Option Uint128) =>
    match value_opt with
    | Some value => value
    | None => u128_zero
    end


let uint128_to_uint256 : Uint128 -> Uint256 =
  fun (x : Uint128) =>
    let ox256 = builtin to_uint256 x in
      match ox256 with
      | None =>
        (* this never happens, hence we throw a division by zero exception just in case *)
        let zero = Uint256 0 in
        builtin div zero zero
      | Some x256 => x256
      end

(* Compute "(x * y) / z" with protection against integer overflows *)
let muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =
    fun (x : Uint128) =>
    fun (y : Uint128) =>
    fun (z : Uint128) =>
      let x256 = uint128_to_uint256 x in
      let y256 = uint128_to_uint256 y in
      let z256 = uint128_to_uint256 z in
      let x_mul_y256 = builtin mul x256 y256 in
      let res256 = builtin div x_mul_y256 z256 in
      let ores128 = builtin to_uint128 res256 in
      match ores128 with
      | None =>
        (* this must never happen, hence we throw an integer overflow exception *)
        let max_uint128 = Uint128 340282366920938463463374607431768211455 in
        let fourtytwo128 = Uint128 42 in
        builtin mul max_uint128 fourtytwo128
      | Some res128 =>
        res128
      end
(* epoch_per_cycle: *)
contract Staking(
    init_contract_owner: ByStr20,
    init_block_num: Uint256,
    init_cycle: Uint32,
    init_rewards_per_cycle: Uint128,
    epoch_per_cycle: Uint256
)

field contract_owner: ByStr20 = init_contract_owner


field last_block_num: Uint256 = init_block_num
field last_cycle: Uint32 = init_cycle
field total_stake: Uint128 = u128_zero
field total_stake_per_cycle: Map Uint32 Uint128 = Emp Uint32 Uint128

field delegate_deposit: Map ByStr20 (Map Uint32 Uint128) = Emp ByStr20 (Map Uint32 Uint128)
field last_withdraw_cycle: Map ByStr20 Uint32 = Emp ByStr20 Uint32


field cycle_rewards_deleg: Uint128 = u128_zero

procedure increase_rewards(reward: Uint128)
  exist_reward <- cycle_rewards_deleg;
  new_reward = builtin add exist_reward reward;
  cycle_rewards_deleg := new_reward
end

procedure duplicate_total_stake_map(cycle_to_increase: Uint32)
  last_cycle_local <- last_cycle;
  total_stake_local <- total_stake;
  current_cycle = builtin add last_cycle_local cycle_to_increase;
  total_stake_per_cycle[current_cycle] := total_stake_local
end


procedure update_stake_map_onchange(is_deposit: Bool, change_amount: Uint128)
  current_bum <- & BLOCKNUMBER;
  current_block_num = bnum_to_uint256 current_bum;
  last_block_num <- last_block_num;
  current_block_num_256 = i256_to_u256 current_block_num;
  block_num_diff = builtin sub current_block_num_256 last_block_num;
  (* if there are 5 cycles need to be updated, then we need update 4 cycles use procedure duplicate_total_stake_map *)
  (* only update the last one upon the change of the stake *)
  cycle_to_increase = builtin div block_num_diff epoch_per_cycle;
  cycle_to_increase_32 = u256_to_u32 cycle_to_increase;
  (* this will create [1,2,3,4] if cycle_to_increase_u32 is 5 *)
  duplicated_list = iota uint32_one cycle_to_increase_32;
  forall duplicated_list duplicate_total_stake_map;
  (* handle the last cycle *)
  current_total_stake <- total_stake;
  last_cycle_local <- last_cycle;
  the_last_cycle = builtin add last_cycle_local cycle_to_increase_32;
  match is_deposit with
  | True =>
    new_total_stake = builtin add current_total_stake change_amount;
    total_stake := new_total_stake;
    total_stake_per_cycle[the_last_cycle] := new_total_stake;
    last_cycle := the_last_cycle
  | False =>
    new_total_stake = builtin sub current_total_stake change_amount;
    total_stake := new_total_stake;
    total_stake_per_cycle[the_last_cycle] := new_total_stake;
    last_cycle := the_last_cycle
  end
end

procedure update_delegate_deposit(user: ByStr20, amount: Uint128)
  last_cycle_local <- last_cycle;
  delegate_deposit_opt <- delegate_deposit[user][last_cycle_local];
  new_amount = match delegate_deposit_opt with
                   | Some delegate =>
                     builtin add delegate amount
                   | None =>
                     amount
                   end;
  delegate_deposit[user][last_cycle_local] := new_amount
end



transition deposit(amount: Uint128)
  (* todo transfer token *)
  update_stake_map_onchange true amount;
  update_delegate_deposit _sender amount
end


procedure calculate_rewards(cycle: Uint32)
  last_reward_cycle = builtin sub cycle uint32_one;
  last_delegate_opt <- delegate_deposit[_sender][last_reward_cycle];
  last_delegate = get_uint128_opt last_delegate_opt;
  delete delegate_deposit[_sender][last_reward_cycle];

  delegate_deposit_opt <- delegate_deposit[_sender][cycle];
  total_delegate_this_cycle = match delegate_deposit_opt with
                              | Some delegate =>
                                builtin add delegate last_delegate
                              | None =>
                                last_delegate
                              end;
  (* todo how to decide this one *)
  total_rewards = init_rewards_per_cycle;
  total_stake_per_opt <- total_stake_per_cycle[cycle];
  match total_stake_per_opt with
  | Some total_stake =>
    e = { _eventname: "calculate_rewards"; total_stake: total_stake; total_rewards: total_rewards; user_stake_this_cycle: total_delegate_this_cycle };
    event e;
    reward = muldiv total_rewards total_delegate_this_cycle total_stake;
    increase_rewards reward
  | None =>
  end
end


transition claim()
  update_stake_map_onchange true u128_zero;

  last_withdraw_cycle_opt <- last_withdraw_cycle[_sender];
  last_withdraw_cycle = get_last_withdraw_cycle last_withdraw_cycle_opt;

  last_cycle_local <- last_cycle;

  from_cycle = builtin add last_withdraw_cycle uint32_one;
  to_cycle = builtin add last_cycle_local uint32_one;
  reward_list = iota from_cycle to_cycle;
  e = { _eventname: "claim"; reward_list: reward_list};
  event e;
  cycle_rewards_deleg := u128_zero;
  forall reward_list calculate_rewards;
  last_withdraw_cycle[_sender] := last_cycle_local
  (* transfer out *)

end